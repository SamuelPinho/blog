{"data":{"markdownRemark":{"html":"<h2>Redes Neurais Artificiais</h2>\n<h3>Representação de um neurônio artificial</h3>\n<ol>\n<li>Um conjunto de sinapses ou elos de ligação</li>\n<li>Somador para as entradas iniciais</li>\n<li>Função de ativação para restringir a saída do neuronio</li>\n</ol>\n<blockquote>\n<p>Professor não sabe explicar o motivo da existência da variável bias.</p>\n</blockquote>\n<h3>Função de Ativação</h3>\n<p>Serve para transformar os valores e alocar eles dentro de 0 e 1.</p>\n<h3>Aprendizado Supervisionado e Não Supervisionado</h3>\n<ul>\n<li><strong>Supervisionado</strong> possui uma tabela que serve para comparar o resultado obtido pela rede neural e pela tabela pré-existente.</li>\n<li><strong>Não Supervisionado</strong> não possui uma tabela, busca apenas um padrão para as entradas e saídas.</li>\n</ul>\n<h3>Código implementado na aula</h3>\n<pre><code class=\"language-python3\">listas = [[0, 1, 2, -1], [0, 2, -5, 1], [1, -2, 3, -1]]\npesos = [0.5, 0.5, 0.5, 0.5]\nvalores_desejados = [-1, 1, 1]\nbias = -1\ntaxa_de_aprendizagem = 0.5\nlista_erros_instantaneos = []\n\n# precisa passar um lista das listas\n\n\ndef primeira_funcao(lista):\n    soma = 0.0\n    for i in range(len(lista)):\n        soma += (lista[i] * pesos[i])\n\n    return soma\n\n\ndef segunda_funcao(resultado_primeira_funcao):\n    sinal_de_saida = funcao_ativacao(resultado_primeira_funcao + bias)\n    return sinal_de_saida\n\n\n# verificar se o erro não foi 0\ndef terceira_funcao(resultado_segunda_funcao, iteracao):\n    erro = valores_desejados[iteracao] - resultado_segunda_funcao\n\n    erro_instantaneo(erro)\n\n    return erro\n\n\ndef quarta_funcao(lista, resultado_terceira_funcao):\n    for i in range(len(lista)):\n        resultado_quarta_funcao = taxa_de_aprendizagem * \\\n            resultado_terceira_funcao * lista[i]\n\n        quinta_funcao(i, resultado_quarta_funcao)\n\n\ndef quinta_funcao(iteracao, resultado_quarta_funcao):\n    pesos[iteracao] += resultado_quarta_funcao\n\n\ndef erro_instantaneo(erro):\n    lista_erros_instantaneos.append(0.5 * pow(erro, 2))\n\n\ndef funcao_ativacao(v):\n    if v > 0:\n        return 1\n    if v == 0:\n        return 0\n    if v &#x3C; 0:\n        return -1\n\n\nfor j in range(100):\n    print(\"\\n Iteração \" + str(j))\n    for i in range(len(listas)):\n        resultado_primeira = primeira_funcao(listas[i])\n        resultado_segunda = segunda_funcao(resultado_primeira)\n        resultado_terceira = terceira_funcao(resultado_segunda, i)\n\n        if(resultado_terceira != 0):\n            quarta_funcao(listas[i], resultado_terceira)\n            print(\"[\"+str(j)+\"]\" + str(pesos))\n        else:\n            print(\"[\"+str(j)+\"]\" + str(pesos) + \" - erro 0\")\n\n\nprint(\"\\n[i] erros instantaneos: \" + str(lista_erros_instantaneos))\n</code></pre>","frontmatter":{"tags":["Tópicos"],"title":"Aula de Redes Neurais","date":"05 outubro, 2018","categorias":["Faculdade"],"description":"Relatório da aula de Tópicos onde foi dada uma introdução sobre o conceito de redes neurais e uma implementação simples em python"}}},"pageContext":{"slug":"/redes_neurais/"}}