{"data":{"markdownRemark":{"html":"<h2>Redes Neurais Artificiais</h2>\n<h3>Representação de um neurônio artificial</h3>\n<ol>\n<li>Um conjunto de sinapses ou elos de ligação</li>\n<li>Somador para as entradas iniciais</li>\n<li>Função de ativação para restringir a saída do neuronio</li>\n</ol>\n<blockquote>\n<p>Professor não sabe explicar o motivo da existência da variável bias.</p>\n</blockquote>\n<h3>Função de Ativação</h3>\n<p>Serve para transformar os valores e alocar eles dentro de 0 e 1.</p>\n<h3>Aprendizado Supervisionado e Não Supervisionado</h3>\n<ul>\n<li><strong>Supervisionado</strong> possui uma tabela que serve para comparar o resultado obtido pela rede neural e pela tabela pré-existente.</li>\n<li><strong>Não Supervisionado</strong> não possui uma tabela, busca apenas um padrão para as entradas e saídas.</li>\n</ul>\n<hr>\n<h3>Código implementado na aula</h3>\n<pre><code class=\"language-python\">LISTA_DE_NUMEROS_INICIAIS = [[0, 1, 2, -1], [0, 2, -5, 1], [1, -2, 3, -1]]\nPESOS = [0.5, 0.5, 0.5, 0.5]\nVALORES_DESEJADOS = [-1, 1, 1]\nBIAS = -1\nTAXA_DE_APRENDIZAGEM = 0.5\nQUANTIDADE_DE_ITERACOES = 10000\n\n\nclass RedeNeural():\n    def __init__(self, lista_de_numeros_iniciais, pesos, valores_desejados,\n                 bias, taxa_de_aprendizagem, quantidade_de_iteracoes):\n        self.lista_de_numeros_iniciais = lista_de_numeros_iniciais\n        self.pesos = pesos\n        self.valores_desejados = valores_desejados\n        self.bias = bias\n        self.taxa_de_aprendizagem = taxa_de_aprendizagem\n        self.quantidade_de_iteracoes = quantidade_de_iteracoes\n\n        self.lista_de_erros_instantaneos = []\n        self.media_dos_erros_instantaneos = 0.0\n\n    def primeira_funcao(self, lista):\n        soma = 0.0\n        for i in range(len(lista)):\n            soma += (lista[i] * self.pesos[i])\n\n        return soma\n\n    def segunda_funcao(self, resultado_primeira_funcao):\n        sinal_de_saida = self.funcao_ativacao(\n            resultado_primeira_funcao + self.bias)\n        return sinal_de_saida\n\n    # verificar se o erro não foi 0\n\n    def terceira_funcao(self, resultado_segunda_funcao, iteracao):\n        erro = self.valores_desejados[iteracao] - resultado_segunda_funcao\n\n        self.erro_instantaneo(erro)\n\n        return erro\n\n    def quarta_funcao(self, lista, resultado_terceira_funcao):\n        for i in range(len(lista)):\n            resultado_quarta_funcao = self.taxa_de_aprendizagem * \\\n                resultado_terceira_funcao * lista[i]\n\n            self.quinta_funcao(i, resultado_quarta_funcao)\n\n    def quinta_funcao(self, iteracao, resultado_quarta_funcao):\n        self.pesos[iteracao] += resultado_quarta_funcao\n\n    def erro_instantaneo(self, erro):\n        self.lista_de_erros_instantaneos.append(0.5 * pow(erro, 2))\n\n        self.media_dos_erros_instantaneos = float(self.calcular_media_dos_erros_instantaneos(\n            self.lista_de_erros_instantaneos) / len(self.lista_de_erros_instantaneos))\n\n    def calcular_media_dos_erros_instantaneos(self, lista_de_erros):\n        total = 0\n        for erro in range(len(lista_de_erros)):\n            total += lista_de_erros[erro]\n\n        return total\n\n    def funcao_ativacao(self, v):\n        if v > 0:\n            return 1\n        if v == 0:\n            return 0\n        if v &#x3C; 0:\n            return -1\n\n    def executar(self):\n        for iteracao in range(self.quantidade_de_iteracoes):\n            print(\"\\n Iteração \" + str(iteracao))\n            for i in range(len(self.lista_de_numeros_iniciais)):\n                resultado_primeira = self.primeira_funcao(\n                    self.lista_de_numeros_iniciais[i])\n                resultado_segunda = self.segunda_funcao(resultado_primeira)\n                resultado_terceira = self.terceira_funcao(\n                    resultado_segunda, i)\n\n                if(resultado_terceira != 0):\n                    self.quarta_funcao(\n                        self.lista_de_numeros_iniciais[i], resultado_terceira)\n                    print(\"[\"+str(iteracao)+\"]\" + str(self.pesos))\n                else:\n                    print(\"[\"+str(iteracao)+\"]\" +\n                          str(self.pesos) + \" - erro 0\")\n\n\nrede_neural = RedeNeural(\n    LISTA_DE_NUMEROS_INICIAIS, PESOS, VALORES_DESEJADOS, BIAS,\n    TAXA_DE_APRENDIZAGEM, QUANTIDADE_DE_ITERACOES)\n\nrede_neural.executar()\n\nprint(\"\\n[i] erros instantaneos: \" +\n      str(rede_neural.lista_de_erros_instantaneos))\n\nprint(\"\\nmédia dos erros instantaneos: \" +\n      str(rede_neural.media_dos_erros_instantaneos))\n</code></pre>","frontmatter":{"tags":["Tópicos"],"title":"Aula de Redes Neurais","date":"05 outubro, 2018","categorias":["Faculdade"],"description":"Relatório da aula de Tópicos onde foi dada uma introdução sobre o conceito de redes neurais e uma implementação simples em python"}}},"pageContext":{"slug":"/redes_neurais/"}}